# æ·±å…¥ç†è§£ ReAct æ¨ç†æ¡†æ¶ï¼šæ„å»ºæ™ºèƒ½ Agent çš„å¼ºå¤§èŒƒå¼

åœ¨å¤§è¯­è¨€æ¨¡å‹ï¼ˆLLMï¼‰é©±åŠ¨çš„æ™ºèƒ½ä½“ï¼ˆAgentï¼‰å¼€å‘ä¸­ï¼Œ**ReActï¼ˆReasoning + Actingï¼‰** æ˜¯ä¸€ç§è¢«å¹¿æ³›é‡‡ç”¨çš„æ¨ç†èŒƒå¼ã€‚å®ƒé€šè¿‡å°†â€œæ€è€ƒâ€ä¸â€œè¡ŒåŠ¨â€äº¤æ›¿è¿›è¡Œï¼Œä½¿ Agent èƒ½å¤ŸåŠ¨æ€è°ƒç”¨å·¥å…·ã€è·å–å¤–éƒ¨ä¿¡æ¯ï¼Œå¹¶é€æ­¥é€¼è¿‘é—®é¢˜çš„æœ€ç»ˆç­”æ¡ˆã€‚æœ¬æ–‡å°†ç»“åˆä¸€æ®µå®Œæ•´çš„ Python å®ç°ä»£ç ï¼Œæ·±å…¥è§£æ ReAct æ¡†æ¶çš„æ ¸å¿ƒæ€æƒ³ã€æ¶æ„è®¾è®¡ä¸å·¥ç¨‹å®è·µã€‚

---

## ä»€ä¹ˆæ˜¯ ReActï¼Ÿ

ReAct æ˜¯ç”± Google Research åœ¨ 2022 å¹´æå‡ºçš„ä¸€ç§ç»“åˆ **æ¨ç†ï¼ˆReasoningï¼‰** ä¸ **è¡ŒåŠ¨ï¼ˆActingï¼‰** çš„æç¤ºå·¥ç¨‹æ–¹æ³•ã€‚å…¶æ ¸å¿ƒæ€æƒ³æ˜¯ï¼š

> **è®©è¯­è¨€æ¨¡å‹ä¸ä»…â€œæ€è€ƒâ€ï¼Œè¿˜èƒ½â€œè¡ŒåŠ¨â€â€”â€”é€šè¿‡è°ƒç”¨å·¥å…·è·å–çœŸå®ä¸–ç•Œçš„ä¿¡æ¯ï¼Œå†åŸºäºæ–°ä¿¡æ¯ç»§ç»­æ¨ç†ã€‚**

ä¸ä¼ ç»Ÿçš„ Chain-of-Thoughtï¼ˆCoTï¼‰ä»…ä¾èµ–å†…éƒ¨æ¨ç†ä¸åŒï¼ŒReAct å…è®¸æ¨¡å‹ä¸ç¯å¢ƒäº¤äº’ï¼Œä»è€Œè§£å†³éœ€è¦å¤–éƒ¨çŸ¥è¯†æˆ–è®¡ç®—èƒ½åŠ›çš„é—®é¢˜ï¼Œä¾‹å¦‚ï¼š
- æŸ¥è¯¢å®æ—¶å¤©æ°”æˆ–è‚¡ç¥¨ä»·æ ¼
- æ‰§è¡Œæ•°å­¦è®¡ç®—
- æœç´¢æ•°æ®åº“æˆ–æ–‡æ¡£
- è°ƒç”¨ä¼ä¸šå†…éƒ¨ API

è¿™ç§â€œæ€è€ƒ â†’ è¡ŒåŠ¨ â†’ è§‚å¯Ÿ â†’ å†æ€è€ƒâ€çš„å¾ªç¯ï¼Œä½¿ Agent å…·å¤‡äº†**å·¥å…·å¢å¼ºï¼ˆTool-Augmentedï¼‰** çš„èƒ½åŠ›ã€‚

---

## ä»£ç å®ç°è§£æ

ä¸‹é¢æä¾›çš„ ReAct Agent å®ç°ä»£ç ï¼Œç†è§£å…¶å¦‚ä½•åœ¨ LangChain + LangGraph ç”Ÿæ€ä¸­è½åœ°ã€‚å¯å‚ç…§æ„å»ºã€‚é…ç½®å¥½keyå’Œbaseurlå³å¯è¿è¡Œã€‚

```python
from langchain_core.prompts import ChatPromptTemplate
from langchain_openai import ChatOpenAI
from langgraph.graph import StateGraph, END
from typing import TypedDict, List, Dict, Any
import json

from langchain_core.tools import tool
import requests
from datetime import datetime
import re

class ReActState(TypedDict):
    """ReActæ¨ç†æ¡†æ¶çš„çŠ¶æ€å®šä¹‰"""
    question: str
    thoughts: List[str]  # æ€è€ƒè¿‡ç¨‹
    actions: List[Dict[str, Any]]  # æ‰§è¡Œçš„è¡ŒåŠ¨
    observations: List[str]  # è§‚å¯Ÿç»“æœ
    final_answer: str
    current_round: int
    max_rounds: int
    is_complete: bool

apikey = ""
baseurl = ""

class ReActAgent:
    def __init__(self, model_name: str = "gpt-3.5-turbo"):
        """
        åˆå§‹åŒ–ReActæ¨ç†ä»£ç†
        Args:
            model_name: ä½¿ç”¨çš„LLMæ¨¡å‹åç§°
        """
        self.llm = ChatOpenAI(model_name="gpt-4.1", base_url=baseurl, api_key=apikey, temperature=0.1)
        
        # å®šä¹‰å¯ç”¨å·¥å…·
        self.tools = [
            self._web_search_tool,
            self._calculate_tool,
            self._get_current_time_tool
        ]
        
        # åˆ›å»ºå·¥å…·å­—å…¸ä»¥ä¾¿å¿«é€ŸæŸ¥æ‰¾
        self.tool_dict = {tool.name: tool for tool in self.tools}
        
        # ReActæç¤ºæ¨¡æ¿
        self.react_prompt = ChatPromptTemplate.from_messages([
            ("system", """ä½ æ˜¯ä¸€ä¸ªReActæ¨ç†åŠ©æ‰‹ï¼Œéœ€è¦äº¤æ›¿è¿›è¡Œæ€è€ƒ(Reasoning)å’Œè¡ŒåŠ¨(Acting)ã€‚
            ä½ çš„å·¥ä½œæµç¨‹æ˜¯ï¼š
            1. æ€è€ƒ(Thought): åˆ†æå½“å‰æƒ…å†µå’Œä¸‹ä¸€æ­¥éœ€è¦åšä»€ä¹ˆ
            2. è¡ŒåŠ¨(Action): æ‰§è¡Œå…·ä½“æ“ä½œï¼ˆä½¿ç”¨å·¥å…·ï¼‰
            3. è§‚å¯Ÿ(Observation): è·å–è¡ŒåŠ¨ç»“æœ
            4. é‡å¤ç›´åˆ°é—®é¢˜è§£å†³"""),
            ("human", """é—®é¢˜: {question}

å½“å‰çŠ¶æ€:
- æ€è€ƒ: {thoughts}
- è¡ŒåŠ¨: {actions}
- è§‚å¯Ÿ: {observations}

è¯·æŒ‰ç…§ReActæ¡†æ¶ç»§ç»­æ¨ç†ï¼Œæ ¼å¼å¦‚ä¸‹ï¼š
æ€è€ƒ: [ä½ çš„æ€è€ƒè¿‡ç¨‹]
è¡ŒåŠ¨: [è¦æ‰§è¡Œçš„å·¥å…·åç§°]({{å‚æ•°}})
è§‚å¯Ÿ: [å·¥å…·æ‰§è¡Œç»“æœ]

æˆ–è€…å¦‚æœé—®é¢˜å·²è§£å†³ï¼š
æ€è€ƒ: [æ€»ç»“æ€§æ€è€ƒ]
æœ€ç»ˆç­”æ¡ˆ: [æœ€ç»ˆç­”æ¡ˆ]""")
        ])

    @tool("web_search")
    def _web_search_tool(self, query: str) -> str:
        """
        æ¨¡æ‹Ÿç½‘ç»œæœç´¢å·¥å…·ï¼ˆä¼ä¸šçº§åº”ç”¨ä¸­å¯ä»¥é›†æˆçœŸå®æœç´¢APIï¼‰
        """
        print(f"ğŸŒ æ‰§è¡Œç½‘ç»œæœç´¢: {query}")
        # è¿™é‡Œä½¿ç”¨æ¨¡æ‹Ÿæ•°æ®ï¼Œå®é™…ä¼ä¸šåº”ç”¨ä¸­å¯ä»¥é›†æˆGoogle Search APIç­‰
        mock_results = {
            "äººå·¥æ™ºèƒ½å‘å±•": "äººå·¥æ™ºèƒ½æŠ€æœ¯åœ¨2024å¹´å–å¾—äº†æ˜¾è‘—è¿›å±•ï¼Œç‰¹åˆ«æ˜¯åœ¨å¤§è¯­è¨€æ¨¡å‹é¢†åŸŸ...",
            "å…¬å¸è´¢æŠ¥": "æ ¹æ®æœ€æ–°è´¢æŠ¥ï¼Œè¯¥å…¬å¸åœ¨2024å¹´Q3è¥æ”¶è¾¾åˆ°10äº¿ç¾å…ƒ...",
            "å¤©æ°”é¢„æŠ¥": "åŒ—äº¬ä»Šæ—¥å¤©æ°”ï¼šæ™´ï¼Œæ°”æ¸©15-25Â°Cï¼Œç©ºæ°”è´¨é‡è‰¯å¥½",
            "è‚¡ç¥¨ä»·æ ¼": "AAPLè‚¡ä»·ï¼š$175.50ï¼Œæ¶¨è·Œå¹…+1.2%"
        }
        return mock_results.get(query, f"æœç´¢ç»“æœ: å…³äº'{query}'çš„è¯¦ç»†ä¿¡æ¯")

    @tool("calculator")
    def _calculate_tool(self, expression: str) -> float:
        """
        è®¡ç®—å™¨å·¥å…·
        """
        print(f"ğŸ§® æ‰§è¡Œè®¡ç®—: {expression}")
        try:
            # å®‰å…¨çš„æ•°å­¦è¡¨è¾¾å¼è®¡ç®—
            import ast
            import operator
            
            # å®šä¹‰å®‰å…¨çš„è¿ç®—ç¬¦
            safe_operators = {
                ast.Add: operator.add,
                ast.Sub: operator.sub,
                ast.Mult: operator.mul,
                ast.Div: operator.truediv,
                ast.Pow: operator.pow,
                ast.USub: operator.neg,
            }
            
            def eval_expr(node):
                if isinstance(node, ast.Num):
                    return node.n
                elif isinstance(node, ast.BinOp):
                    left = eval_expr(node.left)
                    right = eval_expr(node.right)
                    return safe_operators[type(node.op)](left, right)
                elif isinstance(node, ast.UnaryOp):
                    return safe_operators[type(node.op)](eval_expr(node.operand))
                else:
                    raise TypeError(f"ä¸æ”¯æŒçš„è¡¨è¾¾å¼ç±»å‹: {type(node)}")
            
            tree = ast.parse(expression, mode='eval')
            result = eval_expr(tree.body)
            return float(result)
        except Exception as e:
            return f"è®¡ç®—é”™è¯¯: {str(e)}"

    @tool("get_current_time")
    def _get_current_time_tool(self) -> str:
        """
        è·å–å½“å‰æ—¶é—´å·¥å…·
        """
        print("â° è·å–å½“å‰æ—¶é—´")
        return datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    def plan_and_act(self, state: ReActState) -> ReActState:
        """
        ReActçš„æ ¸å¿ƒå¾ªç¯ï¼šè®¡åˆ’å’Œè¡ŒåŠ¨
        """
        current_round = state["current_round"]
        max_rounds = state["max_rounds"]
        
        print(f"\nğŸ”„ ReActå¾ªç¯ - è½®æ¬¡ {current_round + 1}/{max_rounds}")
        
        if current_round >= max_rounds:
            # è¾¾åˆ°æœ€å¤§è½®æ¬¡ï¼Œå°è¯•ç»™å‡ºç­”æ¡ˆ
            updated_state = state.copy()
            updated_state["is_complete"] = True
            updated_state["final_answer"] = "ç”±äºè¾¾åˆ°æœ€å¤§æ¨ç†è½®æ¬¡ï¼Œæœªèƒ½å¾—å‡ºå®Œæ•´ç­”æ¡ˆã€‚"
            return updated_state

        # æ„å»ºä¸Šä¸‹æ–‡
        context = {
            "question": state["question"],
            "thoughts": "\n".join(state["thoughts"]),
            "actions": "\n".join([f"{a['name']}: {a['args']}" for a in state["actions"]]),
            "observations": "\n".join(state["observations"])
            # æ³¨æ„ï¼šè¿™é‡Œä¸å†åŒ…å« 'å‚æ•°' å˜é‡ï¼Œå› ä¸ºå®ƒä¸æ˜¯ä¸Šä¸‹æ–‡çš„ä¸€éƒ¨åˆ†
        }

        # è°ƒç”¨LLMç”Ÿæˆæ€è€ƒã€è¡ŒåŠ¨æˆ–ç­”æ¡ˆ
        chain = self.react_prompt | self.llm
        response = chain.invoke(context)
        
        response_text = response.content
        print(f"LLMå“åº”: {response_text}")
        
        # è§£æå“åº”
        parsed_result = self._parse_react_response(response_text)
        
        updated_state = state.copy()
        updated_state["current_round"] = current_round + 1
        
        if "final_answer" in parsed_result:
            # é—®é¢˜å·²è§£å†³
            updated_state["is_complete"] = True
            updated_state["final_answer"] = parsed_result["final_answer"]
        else:
            # ç»§ç»­æ¨ç†å¾ªç¯
            if "thought" in parsed_result:
                updated_state["thoughts"].append(parsed_result["thought"])
            
            if "action" in parsed_result:
                # æ‰§è¡Œè¡ŒåŠ¨
                action_result = self._execute_action(parsed_result["action"])
                updated_state["actions"].append(parsed_result["action"])
                updated_state["observations"].append(action_result)
        
        return updated_state

    def _parse_react_response(self, response: str) -> Dict[str, Any]:
        """
        è§£æReActå“åº”
        """
        result = {}
        
        # æŸ¥æ‰¾æœ€ç»ˆç­”æ¡ˆ
        final_answer_match = re.search(r'æœ€ç»ˆç­”æ¡ˆ:\s*(.*)', response, re.DOTALL)
        if final_answer_match:
            result["final_answer"] = final_answer_match.group(1).strip()
            return result
        
        # æŸ¥æ‰¾æ€è€ƒ
        thought_match = re.search(r'æ€è€ƒ:\s*(.*?)(?:\n|$)', response, re.DOTALL)
        if thought_match:
            result["thought"] = thought_match.group(1).strip()
        
        # æŸ¥æ‰¾è¡ŒåŠ¨ - ä¿®æ­£æ­£åˆ™è¡¨è¾¾å¼ä»¥æ­£ç¡®åŒ¹é…å·¥å…·åç§°å’Œå‚æ•°
        # åŒ¹é… "è¡ŒåŠ¨: å·¥å…·å({...}) æˆ– è¡ŒåŠ¨: å·¥å…·å({...}, ...)"
        action_match = re.search(r'è¡ŒåŠ¨:\s*([^(]+)\((.*)\)', response, re.DOTALL)
        if action_match:
            tool_name = action_match.group(1).strip()
            tool_args_str = action_match.group(2).strip()
            
            # è§£æå‚æ•°
            try:
                # é¦–å…ˆå°è¯•è§£æä¸ºJSON
                import json
                # ç§»é™¤å¯èƒ½çš„å°¾éšé€—å·å’Œå¤šä½™çš„å­—ç¬¦
                tool_args_str_clean = tool_args_str.strip()
                if tool_args_str_clean.endswith(','):
                    tool_args_str_clean = tool_args_str_clean[:-1]
                
                # å°è¯•è§£æå®Œæ•´çš„JSONå¯¹è±¡
                tool_args = json.loads(tool_args_str_clean)
            except (json.JSONDecodeError, ValueError):
                # å¦‚æœä¸æ˜¯æ ‡å‡†JSONï¼Œä½¿ç”¨æ›´ç®€å•çš„è§£ææ–¹æ³•
                print(f"è­¦å‘Š: æ— æ³•è§£æJSONå‚æ•° '{tool_args_str}', å°è¯•ç®€å•è§£æ")
                try:
                    # ç®€å•çš„é”®å€¼å¯¹è§£æ "key": "value", "key2": "value2"
                    tool_args = {}
                    # ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…é”®å€¼å¯¹
                    pairs = re.findall(r'"([^"]+)"\s*:\s*"([^"]*)"', tool_args_str)
                    for key, value in pairs:
                        tool_args[key] = value
                    # ä¹Ÿå¯ä»¥å°è¯•åŒ¹é…éå­—ç¬¦ä¸²å€¼ï¼Œå¦‚æ•°å­—
                    if not tool_args:
                        # å¦‚æœä¸Šé¢æ²¡åŒ¹é…åˆ°ï¼Œå°è¯•ç®€å•çš„åˆ†å‰²
                        pairs_simple = tool_args_str.split(',')
                        for pair in pairs_simple:
                            if ':' in pair:
                                key, value = pair.split(':', 1)
                                key = key.strip().strip('"\'')
                                value = value.strip().strip('"\'')
                                tool_args[key] = value
                except Exception as e:
                    print(f"ç®€å•è§£æä¹Ÿå¤±è´¥: {e}")
                    # å¦‚æœéƒ½å¤±è´¥ï¼Œå°†æ•´ä¸ªå­—ç¬¦ä¸²ä½œä¸º 'query' å‚æ•°
                    tool_args = {"query": tool_args_str.strip()} 
            
            result["action"] = {
                "name": tool_name,
                "args": tool_args
            }
        
        return result

    def _execute_action(self, action: Dict[str, Any]) -> str:
        """
        æ‰§è¡Œè¡ŒåŠ¨
        """
        tool_name = action["name"]
        tool_args = action["args"]
        
        print(f"ğŸ”§ æ‰§è¡Œè¡ŒåŠ¨: {tool_name} with args {tool_args}")
        
        # æŸ¥æ‰¾å¯¹åº”çš„å·¥å…·å¹¶æ‰§è¡Œ
        if tool_name in self.tool_dict:
            try:
                tool = self.tool_dict[tool_name]
                result = tool.invoke(tool_args)
                return str(result)
            except Exception as e:
                return f"è¡ŒåŠ¨æ‰§è¡Œå¤±è´¥: {str(e)}"
        else:
            return f"æœªçŸ¥å·¥å…·: {tool_name}"

    def create_graph(self) -> StateGraph:
        """
        åˆ›å»ºReActæ¨ç†å›¾
        """
        workflow = StateGraph(ReActState)
        
        # æ·»åŠ èŠ‚ç‚¹
        workflow.add_node("react_loop", self.plan_and_act)
        
        # è®¾ç½®å…¥å£ç‚¹
        workflow.set_entry_point("react_loop")
        
        # æ·»åŠ æ¡ä»¶è¾¹
        workflow.add_conditional_edges(
            "react_loop",
            lambda x: "complete" if x["is_complete"] else "continue",
            {
                "complete": END,
                "continue": "react_loop"
            }
        )
        
        return workflow.compile()

# ä¼ä¸šçº§ReActåº”ç”¨ç¤ºä¾‹
class EnterpriseReActAgent(ReActAgent):
    """
    ä¼ä¸šçº§ReActä»£ç†ï¼Œé›†æˆäº†æ›´å¤šä¼ä¸šçº§å·¥å…·
    """
    
    def __init__(self, model_name: str = "gpt-3.5-turbo"):
        super().__init__(model_name)
        
        # æ·»åŠ ä¼ä¸šçº§å·¥å…·
        enterprise_tools = [
            self._database_query_tool,
            self._api_call_tool,
            self._document_search_tool
        ]
        
        # æ›´æ–°å·¥å…·åˆ—è¡¨å’Œå­—å…¸
        self.tools.extend(enterprise_tools)
        for tool in enterprise_tools:
            self.tool_dict[tool.name] = tool
    
    @tool("database_query")
    def _database_query_tool(self, query: str) -> str:
        """
        æ•°æ®åº“æŸ¥è¯¢å·¥å…·ï¼ˆæ¨¡æ‹Ÿï¼‰
        """
        print(f"ğŸ—„ï¸ æ‰§è¡Œæ•°æ®åº“æŸ¥è¯¢: {query}")
        # æ¨¡æ‹Ÿæ•°æ®åº“æŸ¥è¯¢ç»“æœ
        mock_db_results = {
            "å‘˜å·¥æ€»æ•°": "1500",
            "å­£åº¦è¥æ”¶": "2.5äº¿",
            "å®¢æˆ·æ»¡æ„åº¦": "92%",
            "äº§å“ç¼ºé™·ç‡": "0.3%"
        }
        return mock_db_results.get(query, f"æ•°æ®åº“ä¸­æœªæ‰¾åˆ°å…³äº'{query}'çš„ä¿¡æ¯")

    @tool("api_call")
    def _api_call_tool(self, endpoint: str, params: Dict[str, str]) -> str:
        """
        APIè°ƒç”¨å·¥å…·ï¼ˆæ¨¡æ‹Ÿï¼‰
        """
        print(f"ğŸ”— è°ƒç”¨API: {endpoint} with params {params}")
        # æ¨¡æ‹ŸAPIå“åº”
        return f"APIè°ƒç”¨æˆåŠŸï¼Œè¿”å›æ•°æ®: {{'status': 'success', 'data': 'mock_data'}}"

    @tool("document_search")
    def _document_search_tool(self, keywords: str) -> str:
        """
        æ–‡æ¡£æœç´¢å·¥å…·
        """
        print(f"ğŸ“„ æœç´¢æ–‡æ¡£: {keywords}")
        # æ¨¡æ‹Ÿæ–‡æ¡£æœç´¢ç»“æœ
        mock_doc_results = {
            "å…¬å¸æ”¿ç­–": "å…¬å¸æ”¿ç­–æ–‡æ¡£ï¼šå‘˜å·¥æ‰‹å†Œv2.1ï¼ŒåŒ…å«æœ€æ–°è€ƒå‹¤å’Œç¦åˆ©æ”¿ç­–",
            "æŠ€æœ¯æ–‡æ¡£": "æŠ€æœ¯æ¶æ„æ–‡æ¡£ï¼šå¾®æœåŠ¡æ¶æ„è®¾è®¡ï¼ŒåŒ…å«APIæ¥å£è§„èŒƒ",
            "åˆåŒæ¡æ¬¾": "åˆåŒæ¨¡æ¿ï¼šæ ‡å‡†æœåŠ¡åˆåŒï¼ŒåŒ…å«SLAå’ŒæœåŠ¡æ¡æ¬¾"
        }
        return mock_doc_results.get(keywords, f"æœªæ‰¾åˆ°åŒ…å«'{keywords}'çš„æ–‡æ¡£")

# ä½¿ç”¨ç¤ºä¾‹
def demo_react_agent():
    """
    ReActæ¨ç†æ¡†æ¶æ¼”ç¤º
    """
    print("ğŸš€ å¯åŠ¨ReActæ¨ç†æ¡†æ¶æ¼”ç¤º")
    
    # åˆ›å»ºReActä»£ç†
    react_agent = EnterpriseReActAgent()
    graph = react_agent.create_graph()
    
    # æµ‹è¯•é—®é¢˜ï¼ˆä¼ä¸šåœºæ™¯ï¼‰
    test_question = "è¯·åˆ†ææˆ‘ä»¬å…¬å¸å½“å‰çš„ä¸šç»©æƒ…å†µï¼ŒåŒ…æ‹¬å‘˜å·¥æ•°é‡ã€å­£åº¦è¥æ”¶å’Œå®¢æˆ·æ»¡æ„åº¦ï¼Œå¹¶é¢„æµ‹ä¸‹å­£åº¦çš„å¢é•¿è¶‹åŠ¿ã€‚"
    
    initial_state = {
        "question": test_question,
        "thoughts": ["éœ€è¦æ”¶é›†å…¬å¸ä¸šç»©æ•°æ®"],
        "actions": [],
        "observations": [],
        "final_answer": "",
        "current_round": 0,
        "max_rounds": 5,  # é™åˆ¶æœ€å¤§æ¨ç†è½®æ¬¡
        "is_complete": False
    }
    
    # æ‰§è¡Œæ¨ç†
    result = graph.invoke(initial_state)
    
    print(f"\nğŸ“‹ é—®é¢˜: {result['question']}")
    print(f"ğŸ¯ æœ€ç»ˆç­”æ¡ˆ: {result['final_answer']}")
    print(f"ğŸ“Š æ¨ç†è½®æ¬¡: {result['current_round']}")
    print(f"ğŸ”§ æ‰§è¡Œè¡ŒåŠ¨æ•°: {len(result['actions'])}")
    print(f"ğŸ‘€ è·å–è§‚å¯Ÿæ•°: {len(result['observations'])}")

if __name__ == "__main__":
    # print("=== CoTæ¨ç†æ¡†æ¶æ¼”ç¤º ===")
    # demo_cot_agent()
    
    print("\n=== ReActæ¨ç†æ¡†æ¶æ¼”ç¤º ===")
    demo_react_agent()
```



### 

# 深入理解 ReAct 推理框架：构建智能 Agent 的强大范式

在大语言模型（LLM）驱动的智能体（Agent）开发中，**ReAct（Reasoning + Acting）** 是一种被广泛采用的推理范式。它通过将“思考”与“行动”交替进行，使 Agent 能够动态调用工具、获取外部信息，并逐步逼近问题的最终答案。本文将结合一段完整的 Python 实现代码，深入解析 ReAct 框架的核心思想、架构设计与工程实践。

---

## 什么是 ReAct？

ReAct 是由 Google Research 在 2022 年提出的一种结合 **推理（Reasoning）** 与 **行动（Acting）** 的提示工程方法。其核心思想是：

> **让语言模型不仅“思考”，还能“行动”——通过调用工具获取真实世界的信息，再基于新信息继续推理。**

与传统的 Chain-of-Thought（CoT）仅依赖内部推理不同，ReAct 允许模型与环境交互，从而解决需要外部知识或计算能力的问题，例如：
- 查询实时天气或股票价格
- 执行数学计算
- 搜索数据库或文档
- 调用企业内部 API

这种“思考 → 行动 → 观察 → 再思考”的循环，使 Agent 具备了**工具增强（Tool-Augmented）** 的能力。

---

## 代码实现解析

下面提供的 ReAct Agent 实现代码，理解其如何在 LangChain + LangGraph 生态中落地。可参照构建。配置好key和baseurl即可运行。

```python
from langchain_core.prompts import ChatPromptTemplate
from langchain_openai import ChatOpenAI
from langgraph.graph import StateGraph, END
from typing import TypedDict, List, Dict, Any
import json

from langchain_core.tools import tool
import requests
from datetime import datetime
import re

class ReActState(TypedDict):
    """ReAct推理框架的状态定义"""
    question: str
    thoughts: List[str]  # 思考过程
    actions: List[Dict[str, Any]]  # 执行的行动
    observations: List[str]  # 观察结果
    final_answer: str
    current_round: int
    max_rounds: int
    is_complete: bool

apikey = ""
baseurl = ""

class ReActAgent:
    def __init__(self, model_name: str = "gpt-3.5-turbo"):
        """
        初始化ReAct推理代理
        Args:
            model_name: 使用的LLM模型名称
        """
        self.llm = ChatOpenAI(model_name="gpt-4.1", base_url=baseurl, api_key=apikey, temperature=0.1)
        
        # 定义可用工具
        self.tools = [
            self._web_search_tool,
            self._calculate_tool,
            self._get_current_time_tool
        ]
        
        # 创建工具字典以便快速查找
        self.tool_dict = {tool.name: tool for tool in self.tools}
        
        # ReAct提示模板
        self.react_prompt = ChatPromptTemplate.from_messages([
            ("system", """你是一个ReAct推理助手，需要交替进行思考(Reasoning)和行动(Acting)。
            你的工作流程是：
            1. 思考(Thought): 分析当前情况和下一步需要做什么
            2. 行动(Action): 执行具体操作（使用工具）
            3. 观察(Observation): 获取行动结果
            4. 重复直到问题解决"""),
            ("human", """问题: {question}

当前状态:
- 思考: {thoughts}
- 行动: {actions}
- 观察: {observations}

请按照ReAct框架继续推理，格式如下：
思考: [你的思考过程]
行动: [要执行的工具名称]({{参数}})
观察: [工具执行结果]

或者如果问题已解决：
思考: [总结性思考]
最终答案: [最终答案]""")
        ])

    @tool("web_search")
    def _web_search_tool(self, query: str) -> str:
        """
        模拟网络搜索工具（企业级应用中可以集成真实搜索API）
        """
        print(f"🌐 执行网络搜索: {query}")
        # 这里使用模拟数据，实际企业应用中可以集成Google Search API等
        mock_results = {
            "人工智能发展": "人工智能技术在2024年取得了显著进展，特别是在大语言模型领域...",
            "公司财报": "根据最新财报，该公司在2024年Q3营收达到10亿美元...",
            "天气预报": "北京今日天气：晴，气温15-25°C，空气质量良好",
            "股票价格": "AAPL股价：$175.50，涨跌幅+1.2%"
        }
        return mock_results.get(query, f"搜索结果: 关于'{query}'的详细信息")

    @tool("calculator")
    def _calculate_tool(self, expression: str) -> float:
        """
        计算器工具
        """
        print(f"🧮 执行计算: {expression}")
        try:
            # 安全的数学表达式计算
            import ast
            import operator
            
            # 定义安全的运算符
            safe_operators = {
                ast.Add: operator.add,
                ast.Sub: operator.sub,
                ast.Mult: operator.mul,
                ast.Div: operator.truediv,
                ast.Pow: operator.pow,
                ast.USub: operator.neg,
            }
            
            def eval_expr(node):
                if isinstance(node, ast.Num):
                    return node.n
                elif isinstance(node, ast.BinOp):
                    left = eval_expr(node.left)
                    right = eval_expr(node.right)
                    return safe_operators[type(node.op)](left, right)
                elif isinstance(node, ast.UnaryOp):
                    return safe_operators[type(node.op)](eval_expr(node.operand))
                else:
                    raise TypeError(f"不支持的表达式类型: {type(node)}")
            
            tree = ast.parse(expression, mode='eval')
            result = eval_expr(tree.body)
            return float(result)
        except Exception as e:
            return f"计算错误: {str(e)}"

    @tool("get_current_time")
    def _get_current_time_tool(self) -> str:
        """
        获取当前时间工具
        """
        print("⏰ 获取当前时间")
        return datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    def plan_and_act(self, state: ReActState) -> ReActState:
        """
        ReAct的核心循环：计划和行动
        """
        current_round = state["current_round"]
        max_rounds = state["max_rounds"]
        
        print(f"\n🔄 ReAct循环 - 轮次 {current_round + 1}/{max_rounds}")
        
        if current_round >= max_rounds:
            # 达到最大轮次，尝试给出答案
            updated_state = state.copy()
            updated_state["is_complete"] = True
            updated_state["final_answer"] = "由于达到最大推理轮次，未能得出完整答案。"
            return updated_state

        # 构建上下文
        context = {
            "question": state["question"],
            "thoughts": "\n".join(state["thoughts"]),
            "actions": "\n".join([f"{a['name']}: {a['args']}" for a in state["actions"]]),
            "observations": "\n".join(state["observations"])
            # 注意：这里不再包含 '参数' 变量，因为它不是上下文的一部分
        }

        # 调用LLM生成思考、行动或答案
        chain = self.react_prompt | self.llm
        response = chain.invoke(context)
        
        response_text = response.content
        print(f"LLM响应: {response_text}")
        
        # 解析响应
        parsed_result = self._parse_react_response(response_text)
        
        updated_state = state.copy()
        updated_state["current_round"] = current_round + 1
        
        if "final_answer" in parsed_result:
            # 问题已解决
            updated_state["is_complete"] = True
            updated_state["final_answer"] = parsed_result["final_answer"]
        else:
            # 继续推理循环
            if "thought" in parsed_result:
                updated_state["thoughts"].append(parsed_result["thought"])
            
            if "action" in parsed_result:
                # 执行行动
                action_result = self._execute_action(parsed_result["action"])
                updated_state["actions"].append(parsed_result["action"])
                updated_state["observations"].append(action_result)
        
        return updated_state

    def _parse_react_response(self, response: str) -> Dict[str, Any]:
        """
        解析ReAct响应
        """
        result = {}
        
        # 查找最终答案
        final_answer_match = re.search(r'最终答案:\s*(.*)', response, re.DOTALL)
        if final_answer_match:
            result["final_answer"] = final_answer_match.group(1).strip()
            return result
        
        # 查找思考
        thought_match = re.search(r'思考:\s*(.*?)(?:\n|$)', response, re.DOTALL)
        if thought_match:
            result["thought"] = thought_match.group(1).strip()
        
        # 查找行动 - 修正正则表达式以正确匹配工具名称和参数
        # 匹配 "行动: 工具名({...}) 或 行动: 工具名({...}, ...)"
        action_match = re.search(r'行动:\s*([^(]+)\((.*)\)', response, re.DOTALL)
        if action_match:
            tool_name = action_match.group(1).strip()
            tool_args_str = action_match.group(2).strip()
            
            # 解析参数
            try:
                # 首先尝试解析为JSON
                import json
                # 移除可能的尾随逗号和多余的字符
                tool_args_str_clean = tool_args_str.strip()
                if tool_args_str_clean.endswith(','):
                    tool_args_str_clean = tool_args_str_clean[:-1]
                
                # 尝试解析完整的JSON对象
                tool_args = json.loads(tool_args_str_clean)
            except (json.JSONDecodeError, ValueError):
                # 如果不是标准JSON，使用更简单的解析方法
                print(f"警告: 无法解析JSON参数 '{tool_args_str}', 尝试简单解析")
                try:
                    # 简单的键值对解析 "key": "value", "key2": "value2"
                    tool_args = {}
                    # 使用正则表达式匹配键值对
                    pairs = re.findall(r'"([^"]+)"\s*:\s*"([^"]*)"', tool_args_str)
                    for key, value in pairs:
                        tool_args[key] = value
                    # 也可以尝试匹配非字符串值，如数字
                    if not tool_args:
                        # 如果上面没匹配到，尝试简单的分割
                        pairs_simple = tool_args_str.split(',')
                        for pair in pairs_simple:
                            if ':' in pair:
                                key, value = pair.split(':', 1)
                                key = key.strip().strip('"\'')
                                value = value.strip().strip('"\'')
                                tool_args[key] = value
                except Exception as e:
                    print(f"简单解析也失败: {e}")
                    # 如果都失败，将整个字符串作为 'query' 参数
                    tool_args = {"query": tool_args_str.strip()} 
            
            result["action"] = {
                "name": tool_name,
                "args": tool_args
            }
        
        return result

    def _execute_action(self, action: Dict[str, Any]) -> str:
        """
        执行行动
        """
        tool_name = action["name"]
        tool_args = action["args"]
        
        print(f"🔧 执行行动: {tool_name} with args {tool_args}")
        
        # 查找对应的工具并执行
        if tool_name in self.tool_dict:
            try:
                tool = self.tool_dict[tool_name]
                result = tool.invoke(tool_args)
                return str(result)
            except Exception as e:
                return f"行动执行失败: {str(e)}"
        else:
            return f"未知工具: {tool_name}"

    def create_graph(self) -> StateGraph:
        """
        创建ReAct推理图
        """
        workflow = StateGraph(ReActState)
        
        # 添加节点
        workflow.add_node("react_loop", self.plan_and_act)
        
        # 设置入口点
        workflow.set_entry_point("react_loop")
        
        # 添加条件边
        workflow.add_conditional_edges(
            "react_loop",
            lambda x: "complete" if x["is_complete"] else "continue",
            {
                "complete": END,
                "continue": "react_loop"
            }
        )
        
        return workflow.compile()

# 企业级ReAct应用示例
class EnterpriseReActAgent(ReActAgent):
    """
    企业级ReAct代理，集成了更多企业级工具
    """
    
    def __init__(self, model_name: str = "gpt-3.5-turbo"):
        super().__init__(model_name)
        
        # 添加企业级工具
        enterprise_tools = [
            self._database_query_tool,
            self._api_call_tool,
            self._document_search_tool
        ]
        
        # 更新工具列表和字典
        self.tools.extend(enterprise_tools)
        for tool in enterprise_tools:
            self.tool_dict[tool.name] = tool
    
    @tool("database_query")
    def _database_query_tool(self, query: str) -> str:
        """
        数据库查询工具（模拟）
        """
        print(f"🗄️ 执行数据库查询: {query}")
        # 模拟数据库查询结果
        mock_db_results = {
            "员工总数": "1500",
            "季度营收": "2.5亿",
            "客户满意度": "92%",
            "产品缺陷率": "0.3%"
        }
        return mock_db_results.get(query, f"数据库中未找到关于'{query}'的信息")

    @tool("api_call")
    def _api_call_tool(self, endpoint: str, params: Dict[str, str]) -> str:
        """
        API调用工具（模拟）
        """
        print(f"🔗 调用API: {endpoint} with params {params}")
        # 模拟API响应
        return f"API调用成功，返回数据: {{'status': 'success', 'data': 'mock_data'}}"

    @tool("document_search")
    def _document_search_tool(self, keywords: str) -> str:
        """
        文档搜索工具
        """
        print(f"📄 搜索文档: {keywords}")
        # 模拟文档搜索结果
        mock_doc_results = {
            "公司政策": "公司政策文档：员工手册v2.1，包含最新考勤和福利政策",
            "技术文档": "技术架构文档：微服务架构设计，包含API接口规范",
            "合同条款": "合同模板：标准服务合同，包含SLA和服务条款"
        }
        return mock_doc_results.get(keywords, f"未找到包含'{keywords}'的文档")

# 使用示例
def demo_react_agent():
    """
    ReAct推理框架演示
    """
    print("🚀 启动ReAct推理框架演示")
    
    # 创建ReAct代理
    react_agent = EnterpriseReActAgent()
    graph = react_agent.create_graph()
    
    # 测试问题（企业场景）
    test_question = "请分析我们公司当前的业绩情况，包括员工数量、季度营收和客户满意度，并预测下季度的增长趋势。"
    
    initial_state = {
        "question": test_question,
        "thoughts": ["需要收集公司业绩数据"],
        "actions": [],
        "observations": [],
        "final_answer": "",
        "current_round": 0,
        "max_rounds": 5,  # 限制最大推理轮次
        "is_complete": False
    }
    
    # 执行推理
    result = graph.invoke(initial_state)
    
    print(f"\n📋 问题: {result['question']}")
    print(f"🎯 最终答案: {result['final_answer']}")
    print(f"📊 推理轮次: {result['current_round']}")
    print(f"🔧 执行行动数: {len(result['actions'])}")
    print(f"👀 获取观察数: {len(result['observations'])}")

if __name__ == "__main__":
    # print("=== CoT推理框架演示 ===")
    # demo_cot_agent()
    
    print("\n=== ReAct推理框架演示 ===")
    demo_react_agent()
```



### 
